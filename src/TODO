4. Проверять в *_list, нет ли такого значение уже в списке.
6. Как-то сразу инициализировать ipprotos, без промежуточного ipprotos_list?
7. ipsrv-записи могут вместо циферного кода протокола содержать буквенный(
   tcp вместо 6)?
8. _make_value в протоколах (ip-srv) должен учитывать value_size. Иначе
   нафига мы его передаём?
9. ip-srv: make_value() должен как-то получать знак, что поля нет(:: - в
   конфиге). Если 0 в ip, tcp и udp канает(0-ого протокола и портов нет), то
   0 для icmp не канает - есть type и code 0. Возможно, надо make_value()
   передавать уже строки байт, а не числа? В этом случае, NULL будет означать
   отсутствие поля.
10. производить разбор пакета надо в фильтре. Ибо смысл заранее делать полный
    разбор, например, до http-заголовков, если таких записей в конфиге нет вовсе.
12. dns: при domain_list_add() не делать копию value, а присваивать указатель?
13. добавить PKT_DBG_OUT, PKT_ERR_OUT - макросы будут принимать первым аргументом
    struct pkt и выводить его id и, для ERR, выводить srcip->dstip.
15. Поправить отладочную информацию в фильтрах при добавлении записи. Например,
    для ip-srv надо выводить полное наименование сервиса, для этого надо 
	форматировать сервис со всеми значениями. Нужна для этого функция.
16. Сделать функцию stat в фильтрах, которая вывоводит инфу о кол-ве записей.
17. Видится удобной универсальное значение для элемента дерева. Формат такой:
    MASK[2]|DATA1_LEN[1]|DATA1[DATA1_LEN]|DATA2_LEN[1]|DATA2[DATA2_LEN]|...
	Маска содержит биты, указывающие где кончаются блоки данных. Т.е.
	0x8000 указывает, что присутствует только DATA1; 0xc000 указывает, что
	присутствует DATA1 и DATA2; 0xe000 указывает, что присутствует DATA1 и 
	DATA2 и DATA3; и т.д. Перед блоком данных идёт байт с длинной данного блока,
	потом сразу блок. Длина 0 означает, что значения у блока нет и его брать
	во внимание не надо при сравнивании элементов. Если значение 0, то блок
	будет содержать 0.
	!!Зачем маска? Должно хватить простого числа от 0 до 255, которое будет
	обозначать кол-во блоков. Ведь, если блока нет, то его длина будет равна
	0, поэтому необходимость в маске отсутствует.
19. При работе фильтра по поиску записи в списке для каждого пакета, сначала
    проверять сколько записей в списке. Если 0, то не производить никакой работы.
22. Добавить поддержку http2?
23. Структуры pkt для dns и http полей выделять один раз на поток выполнения.
    Т.о. не будет постоянных операций выделения/очищения памяти. Структура будет
	потихоньку расти до определённого предела.
24. Переделать корневой pkt_nfq в conn. Туда перенести domain и uri.
25. Проверить везде ли в pkt_*.с вызывается list_rm() перед free(pkt) при ошибке.
    И выставляется ли в NULL первый элемент из списка(где это нужно)?
26. Проверить поведение при ошибках памяти (-1 и прочих <0). Везде ли очищается
    корректно pkt(в main.c например).
27. pkt_dump и pkt_free должны работать на любом типе пакета. Что бы можно было
    вызвать функцию из pkt_http.c и она задампила все пакеты в цепочке.
28. Не очищать пакет при ошибке в pkt_*.c - только возвращать код ошибки.
    На самом верхнем уровне(в pkt.c?) будет делаться PKT_ERROUT() для ошибочного
	пакета и pkt_free().
29. Добавить везде(в pkt/*, f_*/*), где возникают ошибки(не ошибочная интерпретация
    одного пакета за другой, а серьёзная ошибка, вроде, ошибки памяти), сообщение
	в лог об ошибках перед return <0.
30. Сделать нормальный конфиг(flex + yacc).
32. сделать сквозную нумерацию кодов ошибок(<0) через все файлы.
36. сделать общие коды возврата при разборе пакета >0. Например, 1 - не мой пакет,
    2 - мой, но не разбирать(например, tls версия ниже 3) и т.д.
